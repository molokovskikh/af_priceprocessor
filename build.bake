import System
import System.Linq.Enumerable
import System.ServiceModel
import LumiSoft.Net.IMAP from "LumiSoft.Net"
import LumiSoft.Net.IMAP.Client
import LumiSoft.Net.Mime
import LumiSoft.Net.SMTP.Client
import System.IO
import System.Xml
import System.Xml.Linq
import System.Xml.XPath.Extensions

[ServiceContract]
interface IWaybillService:
	[OperationContract]
	def ParseWaybill(uints as (uint)) as (uint)


Global(
	Project: "PriceProcessor",
	Server: "processor.adc.analit.net",
	HumanReadableName: "Служба обработки прайс-листов",
	Profile: @catalog,
	NugetPackageName: @RemotePriceProcessor,
	DeployTo: """\\processor.adc.analit.net\apps\priceprocessor\bin\"""
)

#если мы запускаем тесты на сервере не надо загружать проект что бы
#не блокировать библиотеки
task @ready:
	unless Configuration.IsDefined(@notInteractive):
		Engine.Execute("LoadProject")

desc """
вызывает удаленный сервис priceprocessor для разбора накладных
параметры
	dataFile - иммя файла где каждая строка идентификатор из logs.document_logs
	id - идентификатор из  logs.document_logs
"""
task @ParseWaybills:
	binding = NetTcpBinding()
	binding.SendTimeout = TimeSpan.FromMinutes(30)
	binding.OpenTimeout = TimeSpan.FromMinutes(30)
	binding.ReceiveTimeout = TimeSpan.FromMinutes(30)
	binding.Security.Mode = SecurityMode.None
	factory = ChannelFactory[of IWaybillService](binding, "net.tcp://${Globals.Server}:901/WaybillService")
	channel = factory.CreateChannel()
	ids = List[of uint]()
	dataFile = Configuration.Maybe.dataFile
	if dataFile:
		for l in File.ReadAllLines(dataFile.ToString()):
			ids.Add(uint.Parse(l.Trim()))

	if Configuration.Maybe.id:
		ids.Add(Convert.ToUInt32(Configuration.Id))

	results = channel.ParseWaybill(ids.ToArray())
	for result in results:
		print result

task @default, [@Build]

task @Build, [@BuildService]

task @deploy, [@ServiceDeployPipeline]

def IsDocument(mime as Mime):
	for box in mime.MainEntity.To.Mailboxes:
		domain = box.Domain.ToLower()
		return true if domain.EndsWith("waybills.analit.net") \
			or domain.EndsWith("refused.analit.net")
	return false

def IsMiniMail(mime as Mime):
	return false if not mime.MainEntity.To
	for box in mime.MainEntity.To.Mailboxes:
		domain = box.Domain.ToLower()
		return true if domain.EndsWith("docs.analit.net")
	return false

def Resend(attachment as MimeEntity, miniMails as bool):
	attachedMime = Mime.Parse(attachment.Data)
	letterDomain = "root@waybills.analit.net"
	if miniMails:
		letterDomain = "alldocs@docs.analit.net"
	if not miniMails and not IsDocument(attachedMime):
		print "Ignored ${attachedMime.MainEntity.Subject}"
		return
	if miniMails and not IsMiniMail(attachedMime):
		print "Ignored ${attachedMime.MainEntity.Subject}"
		return
	print "Resend ${attachedMime.MainEntity.Subject}"
	SmtpClientEx.QuickSendSmartHost("box.analit.net",
		25,
		Environment.MachineName,
		"service@analit.net",
		(letterDomain,),
		MemoryStream(attachment.Data))

def ResendLetters(miniMails as bool):
	using client = IMAP_Client():
		client.Connect("box.analit.net", 143)
		client.Authenticate("kvasovtest@analit.net", "12345678")
		client.SelectFolder("INBOX")
		ProcessedUID = List of string()
		sequence_set = IMAP_SequenceSet()
		sequence_set.Parse("1:*", long.MaxValue)
		items = client.FetchMessages(sequence_set, IMAP_FetchItem_Flags.UID, false, false)
		for item in items:
			sequence = IMAP_SequenceSet()
			sequence.Parse(item.UID.ToString(), long.MaxValue)
			message = client.FetchMessages(sequence, IMAP_FetchItem_Flags.Message, false, true)
			mine = Mime.Parse(message[0].MessageData)
			for attachment in mine.Attachments:
				if attachment.ContentType_Name == "Unparse.eml":
					Resend(attachment, miniMails)
				else:
					attachedMime = Mime.Parse(attachment.Data)
					Resend(attachedMime.Attachments[0], miniMails)

Desc """
Переотправляет не обработанные накладные, берет письмо из kvasovtest и переотправляет его

Полезна если что то поломалось а пришли накладные
Предполагается что письмо будет в виде <главное письмо> <вложения <письмо с uin не было обработано<вложения <письмо с накладной>>>>
или в виде <письмо с uin не было обработано<вложения <письмо с накладной>>>
"""
Task @ResendWaybills:
	ResendLetters(false)

Desc """
Переотправляет не обработанные мини-письма, берет письмо из kvasovtest и переотправляет его

Полезна если что-то поломалось, а пришли мини-письма, или
Предполагается что письмо будет в виде <главное письмо> <вложения <письмо с uin не было обработано<вложения <письмо с накладной>>>>
или в виде <письмо с uin не было обработано<вложения <письмо с накладной>>>
"""
Task @ResendMiniMails:
	ResendLetters(true)

desc """
обновиляет интерфейс для сервиса протек

у протека свое представление о прекрасном
для опциональных полей они ставят minOccurs=0 что заставляет .net
генерировать безумную обертку
сначала правим wsdl а затем генерирум классы
"""
task "update:wsdl":
	doc = XDocument.Load("http://wjzakaz.protek.ru:20080/axis2/services/EzakazWebService?wsdl")
	for element in doc.Descendants().Where({e| e.Name.LocalName == @element}):
		attr = element.Attribute("minOccurs")
		continue unless attr
		if attr.Value == "0":
			attr.Value = "1"
			element.SetAttributeValue("nillable", "true")
	doc.Save(@wsdl)
	Sh("SvcUtil.exe /nologo /noconfig /targetClientVersion:Version35 wsdl /directory:src/PriceProcessor/Generated")
	Rm(@wsdl)
	name = "src/PriceProcessor/Generated/EzakazWebService.cs"
	print """sed -ri 's/, Order=[0-9]+//' $name"""
	Bash("""sed -ri 's/, Order=[0-9]+//' $name""")
	Bash("""unix2dos $name""")
	Bash("""clean.sh $name""")
