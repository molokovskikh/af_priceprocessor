import System
import System.Linq.Enumerable
import System.ServiceModel
import LumiSoft.Net.IMAP from "lib/LumiSoft.Net.dll"
import LumiSoft.Net.IMAP.Client
import LumiSoft.Net.Mime
import LumiSoft.Net.SMTP.Client
import System.IO
import System.Xml
import System.Xml.Linq
import System.Xml.XPath.Extensions
import file from Deploy.bake
import file from WindowsServiceSupport.bake
import file from Lib.bake
import file from Migration.bake
import file from Test.bake
import file from Tools.bake
import file from DB.bake
import file from MySql.bake

[ServiceContract]
interface IWaybillService:
	[OperationContract]
	def ParseWaybill(uints as (uint)) as (uint)


Global(
	Project : "PriceProcessor",
	Server : "fms.adc.analit.net",
	HumanReadableName : "Служба обработки прайс-листов",
	ServiceName : "PriceProcessorService",
	Profile: @catalog,
	NugetPackageName: @RemotePriceProcessor
)

#если мы запускаем тесты на сервере не надо загружать проект что бы
#не блокировать библиотеки
task @ready:
	unless Configuration.IsDefined(@notInteractive):
		Engine.Execute("LoadProject")

task @ParseWaybills:
	binding = NetTcpBinding()
	binding.SendTimeout = TimeSpan.FromMinutes(30)
	binding.OpenTimeout = TimeSpan.FromMinutes(30)
	binding.ReceiveTimeout = TimeSpan.FromMinutes(30)
	binding.Security.Mode = SecurityMode.None
	factory = ChannelFactory[of IWaybillService](binding, "net.tcp://fms:901/WaybillService")
	channel = factory.CreateChannel()
	ids = List[of uint]()
	dataFile = Configuration.Maybe.dataFile
	if dataFile:
		for l in File.ReadAllLines(dataFile.ToString()):
			ids.Add(uint.Parse(l.Trim()))

	if Configuration.Maybe.id:
		ids.Add(Convert.ToUInt32(Configuration.Id))

	results = channel.ParseWaybill(ids.ToArray())
	for result in results:
		print result

task @default, [@Build]

task @Build, [@BuildService]

task @deploy, [@ServiceDeployPipeline]

def IsDocument(mime as Mime):
	for box in mime.MainEntity.To.Mailboxes:
		domain = box.Domain.ToLower()
		return true if domain.EndsWith("waybills.analit.net") \
			or domain.EndsWith("refused.analit.net")
	return false

def IsMiniMail(mime as Mime):
	return false if not mime.MainEntity.To
	for box in mime.MainEntity.To.Mailboxes:
		domain = box.Domain.ToLower()
		return true if domain.EndsWith("docs.analit.net")
	return false

def Resend(attachment as MimeEntity, miniMails as bool):
	attachedMime = Mime.Parse(attachment.Data)
	letterDomain = "root@waybills.analit.net"
	if miniMails:
		letterDomain = "alldocs@docs.analit.net"
	if not miniMails and not IsDocument(attachedMime):
		print "Ignored ${attachedMime.MainEntity.Subject}"
		return
	if miniMails and not IsMiniMail(attachedMime):
		print "Ignored ${attachedMime.MainEntity.Subject}"
		return
	print "Resend ${attachedMime.MainEntity.Subject}"
	SmtpClientEx.QuickSendSmartHost("box.analit.net",
		25,
		Environment.MachineName,
		"service@analit.net",
		(letterDomain,),
		MemoryStream(attachment.Data))

def ResendLetters(miniMails as bool):
	using client = IMAP_Client():
		client.Connect("box.analit.net", 143)
		client.Authenticate("kvasovtest@analit.net", "12345678")
		client.SelectFolder("INBOX")
		ProcessedUID = List of string()
		sequence_set = IMAP_SequenceSet()
		sequence_set.Parse("1:*", long.MaxValue)
		items = client.FetchMessages(sequence_set, IMAP_FetchItem_Flags.UID, false, false)
		for item in items:
			sequence = IMAP_SequenceSet()
			sequence.Parse(item.UID.ToString(), long.MaxValue)
			message = client.FetchMessages(sequence, IMAP_FetchItem_Flags.Message, false, true)
			mine = Mime.Parse(message[0].MessageData)
			for attachment in mine.Attachments:
				if attachment.ContentType_Name == "Unparse.eml":
					Resend(attachment, miniMails)
				else:
					attachedMime = Mime.Parse(attachment.Data)
					Resend(attachedMime.Attachments[0], miniMails)

Desc """
Переотправляет не обработанные накладные, берет письмо из kvasovtest и переотправляет его

Полезна если что то поломалось а пришли накладные
Предполагается что письмо будет в виде <главное письмо> <вложения <письмо с uin не было обработано<вложения <письмо с накладной>>>>
или в виде <письмо с uin не было обработано<вложения <письмо с накладной>>>
"""
Task @ResendWaybills:
	ResendLetters(false)

Desc """
Переотправляет не обработанные мини-письма, берет письмо из kvasovtest и переотправляет его

Полезна если что-то поломалось, а пришли мини-письма, или
Предполагается что письмо будет в виде <главное письмо> <вложения <письмо с uin не было обработано<вложения <письмо с накладной>>>>
или в виде <письмо с uin не было обработано<вложения <письмо с накладной>>>
"""
Task @ResendMiniMails:
	ResendLetters(true)

desc """
обновиляет интерфейс для сервиса протек

у протека свое представление о прекрасном
для опциональных полей они ставят minOccurs=0 что заставляет .net
генерировать безумную обертку
сначала правим wsdl а затем генерирум классы
"""
task "update:wsdl":
	doc = XDocument.Load("http://wjzakaz.protek.ru:20080/axis2/services/EzakazWebService?wsdl")
	for element in doc.Descendants().Where({e| e.Name.LocalName == @element}):
		attr = element.Attribute("minOccurs")
		continue unless attr
		if attr.Value == "0":
			attr.Value = "1"
			element.SetAttributeValue("nillable", "true")
	doc.Save(@wsdl)
	Sh("SvcUtil.exe /nologo /noconfig /targetClientVersion:Version35 wsdl /directory:src/PriceProcessor/Generated")
	Rm(@wsdl)
	name = "src/PriceProcessor/Generated/EzakazWebService.cs"
	print """sed -ri 's/, Order=[0-9]+//' $name"""
	Bash("""sed -ri 's/, Order=[0-9]+//' $name""")
	Bash("""unix2dos $name""")
	Bash("""clean.sh $name""")
